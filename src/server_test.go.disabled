// server/server_test.go
//
// Integration-style tests for the server package focusing on vhost behavior
// (HTTP and TLS termination) and basic control endpoints.
//
// The file intentionally keeps tests self-contained and avoids requiring a
// real WireGuard UserspaceDevice by using VHostProxy directly for vhost tests.
// Temporarily disabled by automation to allow running only vhost tests.
// To re-enable, restore the original package name and contents from git.
package server

import (
	"bytes"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/http/httptest"
	"net/netip"
	"net/url"
	"strings"
	"testing"
	"time"

	"aquaduct.dev/weft/types"
	"github.com/golang-jwt/jwt/v4"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"golang.zx2c4.com/wireguard/wgctrl/wgtypes"
)



// helper to generate a WireGuard public-key string parseable by wgtypes.ParseKey
func testGenerateClientPubKeyString() string {
	k, err := wgtypes.GenerateKey()
	if err != nil {
		return ""
	}
	return k.PublicKey().String()
}

var _ = Describe("Server Basic Functionality", func() {
	var s *Server
	BeforeEach(func() {
		s = NewServer()
	})

	AfterEach(func() {
		// shutdown the server and close all listeners
		for _, listener := range s.proxies {
			if listener != nil {
				listener.Close()
			}
		}
	})
	It("handles /healthcheck and shutdown", func() {
		s.ConnectionSecret = "test-secret"

		// Create a valid JWT token for the healthcheck
		claims := jwt.MapClaims{
			"sub": "test-proxy",
		}
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
		tokenString, err := token.SignedString([]byte(s.ConnectionSecret))
		Expect(err).ToNot(HaveOccurred())

		// healthcheck
		hReq, _ := http.NewRequest("GET", "/healthcheck", nil)
		hReq.Header.Set("Authorization", "Bearer "+tokenString)

		// Need to add the proxy to the server's tunnels
		s.tunnels["test-proxy"] = peer{}

		hRec := httptest.NewRecorder()
		s.handleHealthcheck(hRec, hReq)
		Expect(hRec.Result().StatusCode).To(Equal(http.StatusOK))

		// shutdown should close proxies and device (none configured)
		shReq, _ := http.NewRequest("POST", "/shutdown", nil)
		shRec := httptest.NewRecorder()
		s.handleShutdown(shRec, shReq)
		Expect(shRec.Result().StatusCode).To(Equal(http.StatusOK))
	})

	It("handles the login flow", func() {
		s.ConnectionSecret = "test-secret-12345678901234567890"

		// Start a test server
		ts := httptest.NewServer(http.HandlerFunc(s.handleLogin))
		defer ts.Close()

		// 1. GET /login to get the challenge
		resp, err := http.Get(ts.URL)
		Expect(err).ToNot(HaveOccurred())
		Expect(resp.StatusCode).To(Equal(http.StatusOK))
		encryptedChallenge, err := io.ReadAll(resp.Body)
		Expect(err).ToNot(HaveOccurred())
		resp.Body.Close()

		// 2. Decrypt the challenge
		decrypted, err := Decrypt(s.ConnectionSecret, encryptedChallenge)
		Expect(err).ToNot(HaveOccurred())
		Expect(strings.HasPrefix(string(decrypted), "server-")).To(BeTrue())
		challenge := strings.TrimPrefix(string(decrypted), "server-")

		// 3. POST the encrypted suffix back to /login
		encrypted, err := Encrypt(s.ConnectionSecret, challenge)
		Expect(err).ToNot(HaveOccurred())

		encodedChallenge := encodeBase64(encrypted)
		reqBodyMap := map[string]any{
			"challenge":  encodedChallenge,
			"proxy_name": "test-proxy",
		}
		jsonBody, err := json.Marshal(reqBodyMap)
		Expect(err).ToNot(HaveOccurred())

		resp, err = http.Post(ts.URL, "application/json", bytes.NewBuffer(jsonBody))
		Expect(err).ToNot(HaveOccurred())
		Expect(resp.StatusCode).To(Equal(http.StatusOK))

		tokenRaw, err := io.ReadAll(resp.Body)
		Expect(err).ToNot(HaveOccurred())
		resp.Body.Close()

		// 4. Verify the JWT
		token, err := jwt.Parse(string(tokenRaw), func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return []byte(s.ConnectionSecret), nil
		})

		Expect(err).ToNot(HaveOccurred())
		Expect(token.Valid).To(BeTrue())
	})

	It("proxies TCP", func() {
		req := &types.ConnectRequest{
			ClientPublicKey: testGenerateClientPubKeyString(),
			RemotePort:      1234,
			Protocol:        "tcp",
			TunnelName:      "tcp-test-1",
		}
		// Ensure server returns expected WgListenPort by setting it for test
		s.WgListenPort = 1234
		resp, err := s.Serve(req)
		Expect(err).ToNot(HaveOccurred())
		Expect(resp.ServerPort).To(Equal(1234))
	})

	It("proxies HTTP", func() {

		up := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Fprint(w, "upstream-body")
		}))
		defer up.Close()

		httpLn, err := net.Listen("tcp", "127.0.0.1:0")
		Expect(err).ToNot(HaveOccurred())
		defer httpLn.Close()
		httpPort := httpLn.Addr().(*net.TCPAddr).Port

		createReq := &types.ConnectRequest{
			ClientPublicKey: testGenerateClientPubKeyString(),
			Hostname:        "test.local",
			Protocol:        "http",
			RemotePort:      httpPort,
			Upstream:        up.URL,
			TunnelName:      "http-test-1",
		}
		// Ensure server WgListenPort is set so responses are predictable
		s.WgListenPort = httpPort
		_, err = s.Serve(createReq)
		Expect(err).ToNot(HaveOccurred())

		// Obtain the proxy for the public port and exercise its handler directly
		proxy := s.VHostProxyManager.Proxy(httpPort, s.device)
		req, _ := http.NewRequest("GET", fmt.Sprintf("http://localhost:%d", httpPort), nil)
		req.Host = "test.local"
		w := httptest.NewRecorder()
		proxy.ServeHTTP(w, req)
		Expect(w.Result().StatusCode).To(Equal(http.StatusOK))
		body, _ := io.ReadAll(w.Result().Body)
		Expect(string(body)).To(ContainSubstring("upstream-body"))
	})

	It("proxies HTTPS", func() {
		// This test registers TLS termination in the VHostProxy and mounts a TLS listener
		// that proxies to an upstream httptest server (device is nil in tests).
		up := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Fprint(w, "hello-secure")
		}))
		defer up.Close()
		// Register TLS vhost directly against the upstream (device is nil in tests).
		certPEM, keyPEM, err := GenerateCert("secure.test")
		Expect(err).ToNot(HaveOccurred())
		upURL, err := url.Parse(up.URL)
		Expect(err).ToNot(HaveOccurred())
		// Use the VHostProxyManager to create/get proxy for default HTTPS port
		proxy := s.VHostProxyManager.Proxy(443, s.device)
		_, err = proxy.AddHostWithTLS("secure.test", upURL, string(certPEM), string(keyPEM))
		Expect(err).ToNot(HaveOccurred())

		handler := proxy.GetTLSHandler("secure.test")
		cfg := proxy.GetTLSConfig("secure.test")
		Expect(handler).ToNot(BeNil())
		Expect(cfg).ToNot(BeNil())

		// Start TLS listener on a dynamic port to avoid collisions.
		ln, err := net.Listen("tcp", "127.0.0.1:0")
		Expect(err).ToNot(HaveOccurred())
		tlsLn := tls.NewListener(ln, cfg)
		go func() {
			_ = http.Serve(tlsLn, handler)
		}()

		addr := ln.Addr().String()
		tr := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
		client := &http.Client{Transport: tr, Timeout: 3 * time.Second}
		url := "https://" + addr + "/"
		req2, _ := http.NewRequest("GET", url, nil)
		// Set Host header to match vhost routing
		req2.Host = "secure.test"
		resp, err := client.Do(req2)
		Expect(err).ToNot(HaveOccurred())
		defer resp.Body.Close()
		b, _ := io.ReadAll(resp.Body)
		Expect(string(b)).To(ContainSubstring("hello-secure"))
	})

	It("creates VHost listeners lazily", func() {

		testTLSPort := 45454 // non-privileged port for test
		// Ensure proxies map (internal) does not contain the test tunnel
		_, existsBefore := s.proxies["deferred-tls-1"]
		Expect(existsBefore).To(BeFalse())

		// Register a TLS vhost that requests that port via RemotePort and hostname.
		up := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			fmt.Fprint(w, "deferred-upstream")
		}))
		defer up.Close()
		certPEM, keyPEM, err := GenerateCert("deferred.test")
		Expect(err).ToNot(HaveOccurred())

		req := &types.ConnectRequest{
			ClientPublicKey: testGenerateClientPubKeyString(),
			RemotePort:      testTLSPort,
			Hostname:        "deferred.test",
			CertificatePEM:  string(certPEM),
			PrivateKeyPEM:   string(keyPEM),
			TunnelName:      "deferred-tls-1",
		}
		// Serve should add the TLS vhost and create the listener lazily for the requested RemotePort.
		_, err = s.Serve(req)
		Expect(err).ToNot(HaveOccurred())

		// Now the proxies map should contain the tunnel name entry because Serve registers the closer by TunnelName.
		_, existsAfter := s.proxies["deferred-tls-1"]
		Expect(existsAfter).To(BeTrue())
	})

	// It serves tcp, udp, http, https and multiple http domains from same IP by checking that the server can handle all of them.
	var _ = Describe("Server Complex Interactions", func() {

		It("returns a descriptive error when two clients request the same public port", func() {

			// First client: should succeed and reserve a serverPort
			req1 := &types.ConnectRequest{
				ClientPublicKey: testGenerateClientPubKeyString(),
				RemotePort:      4321,
				Protocol:        "tcp",
				TunnelName:      "conflict-test-1",
			}
			// Keep WgListenPort in sync so ServerPort matches expected value
			s.WgListenPort = 4321
			resp1, err := s.Serve(req1)
			Expect(err).ToNot(HaveOccurred())
			Expect(resp1.ServerPort).To(Equal(4321))

			// Record the assigned client address (as the server stores it in peers)
			assignedIP := resp1.ClientAddress
			Expect(assignedIP).ToNot(BeEmpty())

			// Second client: use a different client key but request same RemotePort and expect a descriptive error
			req2 := &types.ConnectRequest{
				ClientPublicKey: testGenerateClientPubKeyString(),
				RemotePort:      4321, // same public port
				Protocol:        "tcp",
				TunnelName:      "conflict-test-2",
			}
			_, err = s.Serve(req2)
			Expect(err).To(HaveOccurred())
			Expect(err.Error()).To(ContainSubstring("port_conflict"))
		})
		It("serves tcp, udp, http, https and multiple http domains from same IP", func() {
			// Arrange: Create a new server, upstream servers, and certificates

			tcpLn, err := net.Listen("tcp", "127.0.0.1:0")
			Expect(err).ToNot(HaveOccurred())
			defer tcpLn.Close()
			go func() {
				for {
					conn, err := tcpLn.Accept()
					if err != nil {
						return
					}
					go func(c net.Conn) {
						io.Copy(c, c)
						c.Close()
					}(conn)
				}
			}()
			tcpPort := tcpLn.Addr().(*net.TCPAddr).Port
			udpAddr, err := net.ResolveUDPAddr("udp", "127.0.0.1:0")
			Expect(err).ToNot(HaveOccurred())
			udpConn, err := net.ListenUDP("udp", udpAddr)
			Expect(err).ToNot(HaveOccurred())
			defer udpConn.Close()
			udpPort := udpConn.LocalAddr().(*net.UDPAddr).Port
			go func() {
				buf := make([]byte, 1024)
				for {
					n, addr, err := udpConn.ReadFromUDP(buf)
					if err != nil {
						return
					}
					udpConn.WriteToUDP(buf[:n], addr)
				}
			}()
			httpUp1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				fmt.Fprint(w, "domain1")
			}))
			defer httpUp1.Close()
			u1, _ := url.Parse(httpUp1.URL)
			httpUp2 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				fmt.Fprint(w, "domain2")
			}))
			defer httpUp2.Close()
			u2, _ := url.Parse(httpUp2.URL)
			httpsUp := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				fmt.Fprint(w, "secure")
			}))
			defer httpsUp.Close()
			u3, _ := url.Parse(httpsUp.URL)

			// Act: Register TCP and UDP non-vhosts
			tcpReq := &types.ConnectRequest{
				ClientPublicKey: testGenerateClientPubKeyString(),
				RemotePort:      tcpPort,
				Protocol:        "tcp",
			}
			tcpResp, err := s.Serve(tcpReq)
			Expect(err).ToNot(HaveOccurred())
			udpReq := &types.ConnectRequest{
				ClientPublicKey: testGenerateClientPubKeyString(),
				RemotePort:      udpPort,
				Protocol:        "udp",
			}
			udpResp, err := s.Serve(udpReq)
			Expect(err).ToNot(HaveOccurred())

			// Assert: The server should return the correct server ports
			Expect(tcpResp.ServerPort).To(Equal(tcpPort))
			Expect(udpResp.ServerPort).To(Equal(udpPort))

			// Arrange: Register HTTP vhosts and an HTTP listener
			httpLn, err := net.Listen("tcp", "127.0.0.1:0")
			Expect(err).ToNot(HaveOccurred())
			defer httpLn.Close()
			publicPort := httpLn.Addr().(*net.TCPAddr).Port
			proxy80 := s.VHostProxyManager.Proxy(publicPort, s.device) // created below; need proxy for adding hosts
			_, err = proxy80.AddHost("example.com", u1)
			Expect(err).ToNot(HaveOccurred())
			_, err = proxy80.AddHost("example.org", u2)
			Expect(err).ToNot(HaveOccurred())
			httpLn, err := net.Listen("tcp", "127.0.0.1:0")
			Expect(err).ToNot(HaveOccurred())
			defer httpLn.Close()
			publicPort := httpLn.Addr().(*net.TCPAddr).Port
			go func() {
				http.Serve(httpLn, proxy80)
			}()

			// Act: Send requests to the vhosts
			tr := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
			client := &http.Client{Transport: tr, Timeout: 3 * time.Second}
			req1, _ := http.NewRequest("GET", fmt.Sprintf("http://127.0.0.1:%d/", publicPort), nil)
			req1.Host = "example.com"
			resp1, err := client.Do(req1)
			Expect(err).ToNot(HaveOccurred())
			b1, _ := io.ReadAll(resp1.Body)
			resp1.Body.Close()
			req2, _ := http.NewRequest("GET", fmt.Sprintf("http://127.0.0.1:%d/", publicPort), nil)
			req2.Host = "example.org"
			resp2, err := client.Do(req2)
			Expect(err).ToNot(HaveOccurred())
			b2, _ := io.ReadAll(resp2.Body)
			resp2.Body.Close()

			// Assert: The server should respond with the correct bodies
			Expect(string(b1)).To(ContainSubstring("domain1"))
			Expect(string(b2)).To(ContainSubstring("domain2"))

			// Arrange: Register an HTTPS vhost and a TLS listener
			certPEM, keyPEM, err := GenerateCert("secure.test")
			Expect(err).ToNot(HaveOccurred())
			proxy443 := s.VHostProxyManager.Proxy(443, s.device)
			_, err = proxy443.AddHostWithTLS("secure.test", u3, string(certPEM), string(keyPEM))
			Expect(err).ToNot(HaveOccurred())
			handler := proxy443.GetTLSHandler("secure.test")
			cfg := proxy443.GetTLSConfig("secure.test")
			Expect(handler).ToNot(BeNil())
			Expect(cfg).ToNot(BeNil())
			ln, err := net.Listen("tcp", "127.0.0.1:0")
			Expect(err).ToNot(HaveOccurred())
			tlsLn := tls.NewListener(ln, cfg)
			go func() {
				http.Serve(tlsLn, handler)
			}()
			addr := ln.Addr().String()

			// Act: Send a request to the vhost
			tr2 := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
			client2 := &http.Client{Transport: tr2, Timeout: 3 * time.Second}
			req3, _ := http.NewRequest("GET", "https://"+addr+"/", nil)
			req3.Host = "secure.test"
			resp3, err := client2.Do(req3)

			// Assert: The server should not return an error and the body should contain the upstream body
			Expect(err).ToNot(HaveOccurred())
			b3, _ := io.ReadAll(resp3.Body)
			Expect(string(b3)).To(ContainSubstring("secure"))
			resp3.Body.Close()
		})
	})
})

var _ = Describe("Server IP Pool", func() {
	var s *Server
	BeforeEach(func() {
		s = NewServer()
	})

	AfterEach(func() {
		// shutdown the server and close all listeners
		for _, listener := range s.proxies {
			if listener != nil {
				listener.Close()
			}
		}
	})
	It("should allocate and release IPs from the pool", func() {
		s.subnet = netip.MustParsePrefix("10.1.2.0/29") // Using a small subnet for testing
		s.usedIPs = make(map[netip.Addr]bool)           // re-init for test

		// 1. Get a first IP. Should be .2, since .1 is reserved for server.
		ip1, err := s.GetFreeIPFromPool()
		Expect(err).ToNot(HaveOccurred())
		Expect(ip1.String()).To(Equal("10.1.2.2"))

		// 2. Get a second IP
		ip2, err := s.GetFreeIPFromPool()
		Expect(err).ToNot(HaveOccurred())
		Expect(ip2.String()).To(Equal("10.1.2.3"))

		// 3. Release the first IP
		s.ReturnIPToPool(ip1)

		// 4. Get another IP. Since we iterate from the start, it should re-use the released IP.
		ip3, err := s.GetFreeIPFromPool()
		Expect(err).ToNot(HaveOccurred())
		Expect(ip3.String()).To(Equal("10.1.2.2"))

		// 5. Exhaust the pool. A /29 has 8 addresses, 6 usable host addresses.
		// .0 is network, .7 is broadcast.
		// .1 is reserved for server.
		// Pool: .2, .3, .4, .5, .6
		// Allocated so far: .2, .3 (ip2, ip3).
		// Let's get the rest.
		ip4, err := s.GetFreeIPFromPool() // .4
		Expect(err).ToNot(HaveOccurred())
		Expect(ip4.String()).To(Equal("10.1.2.4"))

		ip5, err := s.GetFreeIPFromPool() // .5
		Expect(err).ToNot(HaveOccurred())
		Expect(ip5.String()).To(Equal("10.1.2.5"))

		ip6, err := s.GetFreeIPFromPool() // .6
		Expect(err).ToNot(HaveOccurred())
		Expect(ip6.String()).To(Equal("10.1.2.6"))

		// Next one should fail. Broadcast .7 is skipped.
		_, err = s.GetFreeIPFromPool()
		Expect(err).To(HaveOccurred())
		Expect(err.Error()).To(Equal("subnet exhausted"))

		// 6. Now, release an IP and try again.
		s.ReturnIPToPool(ip4) // 10.1.2.4
		ip7, err := s.GetFreeIPFromPool()
		Expect(err).ToNot(HaveOccurred())
		Expect(ip7.String()).To(Equal("10.1.2.4"))
	})
})

func encodeBase64(b []byte) string {
	return base64.StdEncoding.EncodeToString(b)
}
